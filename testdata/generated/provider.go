// Code generated by fieldmask; DO NOT EDIT.

package generated

import (
	"github.com/QuangTung97/fieldmask"
	pb "github.com/QuangTung97/fieldmask/testdata/pb"
)

type ProviderInfoFieldMask struct {
	keepFunc func(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo)
}

func NewProviderInfoFieldMask(fields []string) (*ProviderInfoFieldMask, error) {
	fieldInfos, err := fieldmask.ComputeFieldInfos(fields)
	if err != nil {
		return nil, err
	}

	keepFunc, err := pb_ProviderInfo_ComputeKeepFunc(fieldInfos)
	if err != nil {
		return nil, err
	}

	return &ProviderInfoFieldMask{
		keepFunc: keepFunc,
	}, nil
}

func (fm *ProviderInfoFieldMask) Mask(msg *pb.ProviderInfo) *pb.ProviderInfo {
	newMsg := &pb.ProviderInfo{}
	fm.keepFunc(newMsg, msg)
	return newMsg
}

type ProductFieldMask struct {
	keepFunc func(newMsg *pb.Product, msg *pb.Product)
}

func NewProductFieldMask(fields []string) (*ProductFieldMask, error) {
	fieldInfos, err := fieldmask.ComputeFieldInfos(fields)
	if err != nil {
		return nil, err
	}

	keepFunc, err := pb_Product_ComputeKeepFunc(fieldInfos)
	if err != nil {
		return nil, err
	}

	return &ProductFieldMask{
		keepFunc: keepFunc,
	}, nil
}

func (fm *ProductFieldMask) Mask(msg *pb.Product) *pb.Product {
	newMsg := &pb.Product{}
	fm.keepFunc(newMsg, msg)
	return newMsg
}

func pb_ProviderInfo_ComputeKeepFunc(fieldInfos []fieldmask.FieldInfo) (func(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo), error) {
	if len(fieldInfos) == 0 {
		return func(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo) {
			*newMsg = *msg
		}, nil
	}

	var subFuncs []func(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo)

	for _, field := range fieldInfos {
		isSimpleField := true

		switch field.JsonName {
		case "id":
			subFuncs = append(subFuncs, pb_ProviderInfo_Keep_Id)
		case "name":
			subFuncs = append(subFuncs, pb_ProviderInfo_Keep_Name)
		case "logo":
			subFuncs = append(subFuncs, pb_ProviderInfo_Keep_Logo)
		case "imageUrl":
			subFuncs = append(subFuncs, pb_ProviderInfo_Keep_ImageUrl)
		default:
			return nil, fieldmask.ErrFieldNotFound(field.JsonName)
		}

		if isSimpleField && len(field.SubFields) > 0 {
			return nil, fieldmask.PrependParentField(fieldmask.ErrFieldNotFound(field.SubFields[0].JsonName), field.JsonName)
		}
	}

	return func(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo) {
		for _, fn := range subFuncs {
			fn(newMsg, msg)
		}
	}, nil
}

func pb_Product_ComputeKeepFunc(fieldInfos []fieldmask.FieldInfo) (func(newMsg *pb.Product, msg *pb.Product), error) {
	if len(fieldInfos) == 0 {
		return func(newMsg *pb.Product, msg *pb.Product) {
			*newMsg = *msg
		}, nil
	}

	var subFuncs []func(newMsg *pb.Product, msg *pb.Product)

	for _, field := range fieldInfos {
		isSimpleField := true

		switch field.JsonName {
		case "sku":
			subFuncs = append(subFuncs, pb_Product_Keep_Sku)
		case "provider":
			isSimpleField = false
			keepFunc, err := pb_ProviderInfo_ComputeKeepFunc(field.SubFields)
			if err != nil {
				return nil, fieldmask.PrependParentField(err, "provider")
			}
			subFuncs = append(subFuncs, func(newMsg *pb.Product, msg *pb.Product) {
				newSubMsg := &pb.ProviderInfo{}
				keepFunc(newSubMsg, msg.Provider)
				newMsg.Provider = newSubMsg
			})
		case "attributes":
			isSimpleField = false
			keepFunc, err := pb_Attribute_ComputeKeepFunc(field.SubFields)
			if err != nil {
				return nil, fieldmask.PrependParentField(err, "attributes")
			}
			subFuncs = append(subFuncs, func(newMsg *pb.Product, msg *pb.Product) {
				msgList := make([]*pb.Attribute, 0, len(msg.Attributes))
				for _, e := range msg.Attributes {
					newSubMsg := &pb.Attribute{}
					keepFunc(newSubMsg, e)
					msgList = append(msgList, newSubMsg)
				}
				newMsg.Attributes = msgList
			})
		case "sellerIds":
			subFuncs = append(subFuncs, pb_Product_Keep_SellerIds)
		case "brandCodes":
			subFuncs = append(subFuncs, pb_Product_Keep_BrandCodes)
		default:
			return nil, fieldmask.ErrFieldNotFound(field.JsonName)
		}

		if isSimpleField && len(field.SubFields) > 0 {
			return nil, fieldmask.PrependParentField(fieldmask.ErrFieldNotFound(field.SubFields[0].JsonName), field.JsonName)
		}
	}

	return func(newMsg *pb.Product, msg *pb.Product) {
		for _, fn := range subFuncs {
			fn(newMsg, msg)
		}
	}, nil
}

func pb_Attribute_ComputeKeepFunc(fieldInfos []fieldmask.FieldInfo) (func(newMsg *pb.Attribute, msg *pb.Attribute), error) {
	if len(fieldInfos) == 0 {
		return func(newMsg *pb.Attribute, msg *pb.Attribute) {
			*newMsg = *msg
		}, nil
	}

	var subFuncs []func(newMsg *pb.Attribute, msg *pb.Attribute)

	for _, field := range fieldInfos {
		isSimpleField := true

		switch field.JsonName {
		case "id":
			subFuncs = append(subFuncs, pb_Attribute_Keep_Id)
		case "code":
			subFuncs = append(subFuncs, pb_Attribute_Keep_Code)
		case "name":
			subFuncs = append(subFuncs, pb_Attribute_Keep_Name)
		case "options":
			isSimpleField = false
			keepFunc, err := pb_Option_ComputeKeepFunc(field.SubFields)
			if err != nil {
				return nil, fieldmask.PrependParentField(err, "options")
			}
			subFuncs = append(subFuncs, func(newMsg *pb.Attribute, msg *pb.Attribute) {
				msgList := make([]*pb.Option, 0, len(msg.Options))
				for _, e := range msg.Options {
					newSubMsg := &pb.Option{}
					keepFunc(newSubMsg, e)
					msgList = append(msgList, newSubMsg)
				}
				newMsg.Options = msgList
			})
		default:
			return nil, fieldmask.ErrFieldNotFound(field.JsonName)
		}

		if isSimpleField && len(field.SubFields) > 0 {
			return nil, fieldmask.PrependParentField(fieldmask.ErrFieldNotFound(field.SubFields[0].JsonName), field.JsonName)
		}
	}

	return func(newMsg *pb.Attribute, msg *pb.Attribute) {
		for _, fn := range subFuncs {
			fn(newMsg, msg)
		}
	}, nil
}

func pb_Option_ComputeKeepFunc(fieldInfos []fieldmask.FieldInfo) (func(newMsg *pb.Option, msg *pb.Option), error) {
	if len(fieldInfos) == 0 {
		return func(newMsg *pb.Option, msg *pb.Option) {
			*newMsg = *msg
		}, nil
	}

	var subFuncs []func(newMsg *pb.Option, msg *pb.Option)

	for _, field := range fieldInfos {
		isSimpleField := true

		switch field.JsonName {
		case "code":
			subFuncs = append(subFuncs, pb_Option_Keep_Code)
		case "name":
			subFuncs = append(subFuncs, pb_Option_Keep_Name)
		default:
			return nil, fieldmask.ErrFieldNotFound(field.JsonName)
		}

		if isSimpleField && len(field.SubFields) > 0 {
			return nil, fieldmask.PrependParentField(fieldmask.ErrFieldNotFound(field.SubFields[0].JsonName), field.JsonName)
		}
	}

	return func(newMsg *pb.Option, msg *pb.Option) {
		for _, fn := range subFuncs {
			fn(newMsg, msg)
		}
	}, nil
}

// =========================================
// ProviderInfo Keep Functions
// =========================================

func pb_ProviderInfo_Keep_Id(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo) {
	newMsg.Id = msg.Id
}

func pb_ProviderInfo_Keep_Name(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo) {
	newMsg.Name = msg.Name
}

func pb_ProviderInfo_Keep_Logo(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo) {
	newMsg.Logo = msg.Logo
}

func pb_ProviderInfo_Keep_ImageUrl(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo) {
	newMsg.ImageUrl = msg.ImageUrl
}

// =========================================
// Product Keep Functions
// =========================================

func pb_Product_Keep_Sku(newMsg *pb.Product, msg *pb.Product) {
	newMsg.Sku = msg.Sku
}

func pb_Product_Keep_SellerIds(newMsg *pb.Product, msg *pb.Product) {
	newMsg.SellerIds = msg.SellerIds
}

func pb_Product_Keep_BrandCodes(newMsg *pb.Product, msg *pb.Product) {
	newMsg.BrandCodes = msg.BrandCodes
}

// =========================================
// Attribute Keep Functions
// =========================================

func pb_Attribute_Keep_Id(newMsg *pb.Attribute, msg *pb.Attribute) {
	newMsg.Id = msg.Id
}

func pb_Attribute_Keep_Code(newMsg *pb.Attribute, msg *pb.Attribute) {
	newMsg.Code = msg.Code
}

func pb_Attribute_Keep_Name(newMsg *pb.Attribute, msg *pb.Attribute) {
	newMsg.Name = msg.Name
}

// =========================================
// Option Keep Functions
// =========================================

func pb_Option_Keep_Code(newMsg *pb.Option, msg *pb.Option) {
	newMsg.Code = msg.Code
}

func pb_Option_Keep_Name(newMsg *pb.Option, msg *pb.Option) {
	newMsg.Name = msg.Name
}
