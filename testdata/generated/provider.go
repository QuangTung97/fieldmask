// Code generated by fieldmask; DO NOT EDIT.

package generated

import (
	"github.com/QuangTung97/fieldmask/fields"
	pb "github.com/QuangTung97/fieldmask/testdata/pb"
)

type ProviderInfoFieldMask struct {
	keepFunc     func(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo)
	maskedFields []fields.FieldInfo
}

func NewProviderInfoFieldMask(maskedFields []string, options ...fields.Option) (*ProviderInfoFieldMask, error) {
	fieldInfos, err := fields.ComputeFieldInfos(maskedFields, options...)
	if err != nil {
		return nil, err
	}

	keepFunc, err := pb_ProviderInfo_ComputeKeepFunc(fieldInfos)
	if err != nil {
		return nil, err
	}

	return &ProviderInfoFieldMask{
		keepFunc:     keepFunc,
		maskedFields: fieldInfos,
	}, nil
}

func (fm *ProviderInfoFieldMask) Mask(msg *pb.ProviderInfo) *pb.ProviderInfo {
	newMsg := &pb.ProviderInfo{}
	fm.keepFunc(newMsg, msg)
	return newMsg
}

func (fm *ProviderInfoFieldMask) GetMaskedFields() []fields.FieldInfo {
	return fm.maskedFields
}

type ProductFieldMask struct {
	keepFunc     func(newMsg *pb.Product, msg *pb.Product)
	maskedFields []fields.FieldInfo
}

func NewProductFieldMask(maskedFields []string, options ...fields.Option) (*ProductFieldMask, error) {
	fieldInfos, err := fields.ComputeFieldInfos(maskedFields, options...)
	if err != nil {
		return nil, err
	}

	keepFunc, err := pb_Product_ComputeKeepFunc(fieldInfos)
	if err != nil {
		return nil, err
	}

	return &ProductFieldMask{
		keepFunc:     keepFunc,
		maskedFields: fieldInfos,
	}, nil
}

func (fm *ProductFieldMask) Mask(msg *pb.Product) *pb.Product {
	newMsg := &pb.Product{}
	fm.keepFunc(newMsg, msg)
	return newMsg
}

func (fm *ProductFieldMask) GetMaskedFields() []fields.FieldInfo {
	return fm.maskedFields
}

func pb_ProviderInfo_ComputeKeepFunc(fieldInfos []fields.FieldInfo) (func(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo), error) {
	if len(fieldInfos) == 0 {
		return func(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo) {
			*newMsg = *msg
		}, nil
	}

	var subFuncs []func(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo)

	for _, field := range fieldInfos {
		isSimpleField := true

		switch field.FieldName {
		case "id":
			subFuncs = append(subFuncs, pb_ProviderInfo_Keep_Id)
		case "name":
			subFuncs = append(subFuncs, pb_ProviderInfo_Keep_Name)
		case "logo":
			subFuncs = append(subFuncs, pb_ProviderInfo_Keep_Logo)
		case "imageUrl":
			subFuncs = append(subFuncs, pb_ProviderInfo_Keep_ImageUrl)
		default:
			return nil, fields.ErrFieldNotFound(field.FieldName)
		}

		if isSimpleField && len(field.SubFields) > 0 {
			return nil, fields.PrependParentField(fields.ErrFieldNotFound(field.SubFields[0].FieldName), field.FieldName)
		}
	}

	return func(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo) {
		for _, fn := range subFuncs {
			fn(newMsg, msg)
		}
	}, nil
}

func pb_Product_ComputeKeepFunc(fieldInfos []fields.FieldInfo) (func(newMsg *pb.Product, msg *pb.Product), error) {
	if len(fieldInfos) == 0 {
		return func(newMsg *pb.Product, msg *pb.Product) {
			*newMsg = *msg
		}, nil
	}

	var subFuncs []func(newMsg *pb.Product, msg *pb.Product)

	for _, field := range fieldInfos {
		isSimpleField := true

		switch field.FieldName {
		case "sku":
			subFuncs = append(subFuncs, pb_Product_Keep_Sku)
		case "provider":
			isSimpleField = false
			keepFunc, err := pb_ProviderInfo_ComputeKeepFunc(field.SubFields)
			if err != nil {
				return nil, fields.PrependParentField(err, "provider")
			}
			subFuncs = append(subFuncs, func(newMsg *pb.Product, msg *pb.Product) {
				newSubMsg := &pb.ProviderInfo{}
				keepFunc(newSubMsg, msg.Provider)
				newMsg.Provider = newSubMsg
			})
		case "attributes":
			isSimpleField = false
			keepFunc, err := pb_Attribute_ComputeKeepFunc(field.SubFields)
			if err != nil {
				return nil, fields.PrependParentField(err, "attributes")
			}
			subFuncs = append(subFuncs, func(newMsg *pb.Product, msg *pb.Product) {
				msgList := make([]*pb.Attribute, 0, len(msg.Attributes))
				for _, e := range msg.Attributes {
					newSubMsg := &pb.Attribute{}
					keepFunc(newSubMsg, e)
					msgList = append(msgList, newSubMsg)
				}
				newMsg.Attributes = msgList
			})
		case "sellerIds":
			subFuncs = append(subFuncs, pb_Product_Keep_SellerIds)
		case "brandCodes":
			subFuncs = append(subFuncs, pb_Product_Keep_BrandCodes)
		default:
			return nil, fields.ErrFieldNotFound(field.FieldName)
		}

		if isSimpleField && len(field.SubFields) > 0 {
			return nil, fields.PrependParentField(fields.ErrFieldNotFound(field.SubFields[0].FieldName), field.FieldName)
		}
	}

	return func(newMsg *pb.Product, msg *pb.Product) {
		for _, fn := range subFuncs {
			fn(newMsg, msg)
		}
	}, nil
}

func pb_Attribute_ComputeKeepFunc(fieldInfos []fields.FieldInfo) (func(newMsg *pb.Attribute, msg *pb.Attribute), error) {
	if len(fieldInfos) == 0 {
		return func(newMsg *pb.Attribute, msg *pb.Attribute) {
			*newMsg = *msg
		}, nil
	}

	var subFuncs []func(newMsg *pb.Attribute, msg *pb.Attribute)

	for _, field := range fieldInfos {
		isSimpleField := true

		switch field.FieldName {
		case "id":
			subFuncs = append(subFuncs, pb_Attribute_Keep_Id)
		case "code":
			subFuncs = append(subFuncs, pb_Attribute_Keep_Code)
		case "name":
			subFuncs = append(subFuncs, pb_Attribute_Keep_Name)
		case "options":
			isSimpleField = false
			keepFunc, err := pb_Option_ComputeKeepFunc(field.SubFields)
			if err != nil {
				return nil, fields.PrependParentField(err, "options")
			}
			subFuncs = append(subFuncs, func(newMsg *pb.Attribute, msg *pb.Attribute) {
				msgList := make([]*pb.Option, 0, len(msg.Options))
				for _, e := range msg.Options {
					newSubMsg := &pb.Option{}
					keepFunc(newSubMsg, e)
					msgList = append(msgList, newSubMsg)
				}
				newMsg.Options = msgList
			})
		default:
			return nil, fields.ErrFieldNotFound(field.FieldName)
		}

		if isSimpleField && len(field.SubFields) > 0 {
			return nil, fields.PrependParentField(fields.ErrFieldNotFound(field.SubFields[0].FieldName), field.FieldName)
		}
	}

	return func(newMsg *pb.Attribute, msg *pb.Attribute) {
		for _, fn := range subFuncs {
			fn(newMsg, msg)
		}
	}, nil
}

func pb_Option_ComputeKeepFunc(fieldInfos []fields.FieldInfo) (func(newMsg *pb.Option, msg *pb.Option), error) {
	if len(fieldInfos) == 0 {
		return func(newMsg *pb.Option, msg *pb.Option) {
			*newMsg = *msg
		}, nil
	}

	var subFuncs []func(newMsg *pb.Option, msg *pb.Option)

	for _, field := range fieldInfos {
		isSimpleField := true

		switch field.FieldName {
		case "code":
			subFuncs = append(subFuncs, pb_Option_Keep_Code)
		case "name":
			subFuncs = append(subFuncs, pb_Option_Keep_Name)
		default:
			return nil, fields.ErrFieldNotFound(field.FieldName)
		}

		if isSimpleField && len(field.SubFields) > 0 {
			return nil, fields.PrependParentField(fields.ErrFieldNotFound(field.SubFields[0].FieldName), field.FieldName)
		}
	}

	return func(newMsg *pb.Option, msg *pb.Option) {
		for _, fn := range subFuncs {
			fn(newMsg, msg)
		}
	}, nil
}

// =========================================
// ProviderInfo Keep Functions
// =========================================

func pb_ProviderInfo_Keep_Id(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo) {
	newMsg.Id = msg.Id
}

func pb_ProviderInfo_Keep_Name(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo) {
	newMsg.Name = msg.Name
}

func pb_ProviderInfo_Keep_Logo(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo) {
	newMsg.Logo = msg.Logo
}

func pb_ProviderInfo_Keep_ImageUrl(newMsg *pb.ProviderInfo, msg *pb.ProviderInfo) {
	newMsg.ImageUrl = msg.ImageUrl
}

// =========================================
// Product Keep Functions
// =========================================

func pb_Product_Keep_Sku(newMsg *pb.Product, msg *pb.Product) {
	newMsg.Sku = msg.Sku
}

func pb_Product_Keep_SellerIds(newMsg *pb.Product, msg *pb.Product) {
	newMsg.SellerIds = msg.SellerIds
}

func pb_Product_Keep_BrandCodes(newMsg *pb.Product, msg *pb.Product) {
	newMsg.BrandCodes = msg.BrandCodes
}

// =========================================
// Attribute Keep Functions
// =========================================

func pb_Attribute_Keep_Id(newMsg *pb.Attribute, msg *pb.Attribute) {
	newMsg.Id = msg.Id
}

func pb_Attribute_Keep_Code(newMsg *pb.Attribute, msg *pb.Attribute) {
	newMsg.Code = msg.Code
}

func pb_Attribute_Keep_Name(newMsg *pb.Attribute, msg *pb.Attribute) {
	newMsg.Name = msg.Name
}

// =========================================
// Option Keep Functions
// =========================================

func pb_Option_Keep_Code(newMsg *pb.Option, msg *pb.Option) {
	newMsg.Code = msg.Code
}

func pb_Option_Keep_Name(newMsg *pb.Option, msg *pb.Option) {
	newMsg.Name = msg.Name
}
